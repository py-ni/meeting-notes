- new version of the PEP is at Google documents, please read and comment
    - overall it removes some of the technical details and focuses on the general "vision"

- Ken has examples of how the new API can deliver performance with boxed integers
  and better debugging experience of ref leaks. Those will be presented at the CPython
  core sprint in ~2weeks.

- discussion about error handling:
    - Mark: we want to distinguish "no result" (1) and "error" (0) on ABI level, but it is OK to then fetch the exception from context/thread local via API call
    - Anto: we can have tagged pointers scheme in the ABI and return the tagged exception in the result
	- others raised concerns about taking to much space from the possible pointer range
    Petr: do we want type for "ReferenceOrError", Anto git of this: https://gist.github.com/antocuni/91da3de8f8723d9f61de10ced51e8f81
	- Petr: we want this for documentation purposes (can be the same typedef in C)
	- Stepan: we want this metadata encoded in the API spec, Rust bindings may generate their code from the API spec and not from C headers
        - later on we convinced ourselves that we want a different type on C level and some sort of type system

- discussion about casting/type system:
    - PyRef, PyRefOrError, PyListRef, PyListOrErrorRef
    - unsafe downcast checks in debug mode
        - issue: this would require recompilation
        - Anto's idea: in debug the downcast is still unsafe, but all functions that take PyListRef will immediately check
    - do we want PyListRef to be only builtin list excluding subclasses?
        - conclusion: yes, because we want to use it not only as a safety measure, but for performance reasons, example:
            - PyNI_List_GetItem(PyListRef ref, index) skips slots and goes directly to the underlying storage
            - won't make a difference on stable ABI, where this is a call anyway, but for Python specific ABI this
                can compile down to the right macros
            - safe downcast from PyRef to PyListRef should succeed only for builtin list => then one can use PyNI_List_GetItem,
                otherwise one should fallback to PyNI_Object_GetItem if support for generic sequences is desired
            - remark that occured to me (Stepan) when writing the notes: this approach would require one extra ABI
                call (the check) when running on stable ABI where the distinction between PyNI_List_GetItem and
                PyNI_Object_GetItem will be minimal, because they'll be dominated by the full function call overhead
                - can we specify that stable ABI always fails those downcasts,
                so at compile time the cast will be folded and we will end up only with PyNI_Object_GetItem?

- possible action items for everyone:
    - experiment with the API generator and different API approaches (to errors, types, etc.): https://github.com/py-ni/api
    - take a look at the new PEP version
