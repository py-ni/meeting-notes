* Discussion about what APIs should be promoted to the new API
    * Note from Petr: anything without leading underscore is in theory "stable API"
    * certainly the current limited API (functions that do not follow the "rules for good API" as already defined by the C API working group would be updated to follow them or left out if there is an alternative)
    * in parallel with the new API effort, things are already being either removed or moved to the limited API
    * what about some very VMs specific APIs, e.g., monitoring, debugging, ...
        * seems we don't really have good overview of those, GraalPy/PyPy people could look into it and identify APIs that should/can stay VM specific

* Discussion about "ABI backends"
    * the API can have multiple implementations that will have different ABIs
    * CPython version specific implementation will just directly access structs, etc. - "the fast mode"
    * Universal implementation will dispatch to a function from a vtable in the context
    * Mark: in theory, we can have "stable" ABI, which would be less portable (no indirection through the context), but would still provide some stability guarantees on CPython. We don't have to do that in practice, but it is a demonstration of the possibilities

* Discussion about API definition
    * Stepan showed how this is done in HPy, some pointers:
        * definition of the API: https://github.com/hpyproject/hpy/blob/b57a33c1cec766a1cc3e89f6fd1e2eff73ba9381/hpy/tools/autogen/public_api.h
        * this is parsed by pycparser, which generates 2 implementations:
            * cpython ABI: https://github.com/hpyproject/hpy/blob/b57a33c1cec766a1cc3e89f6fd1e2eff73ba9381/hpy/devel/include/hpy/cpython/misc.h#L526
            * universal ABI: https://github.com/hpyproject/hpy/blob/b57a33c1cec766a1cc3e89f6fd1e2eff73ba9381/hpy/devel/include/hpy/universal/autogen_trampolines.h#L57
            * Implementations of HPy APIs that match CPython APIs 1:1 (with mechanical transformation from/to handles) are also generated, this can save lots of code/work
            * Some APIs have hand-written implementation for performance or if the HPy contract/semantics do not match exactly 1:1 to a CPython C API, example: https://github.com/hpyproject/hpy/blob/b57a33c1cec766a1cc3e89f6fd1e2eff73ba9381/hpy/devel/include/hpy/universal/misc_trampolines.h#L4
            * The generator: https://github.com/hpyproject/hpy/blob/b57a33c1cec766a1cc3e89f6fd1e2eff73ba9381/hpy/tools/autogen/hpyfunc.py
    * Mark showed his prototype that defines the API in Python: https://github.com/markshannon/New-C-API-for-Python/blob/main/api/generate/api.py
    * We all agreed on defining the API in Python in similar way
    * The generated C API should be C++ safe. 
    * The API definition and (ideally also) the tooling around it should be amendable for other languages, so that we/PyO3 maintainers can generate Rust API directly from it bypassing the C API

* Discussion about the context argument:
    * Mark: it should be fully opaque one word value
    * Anto/Stepan: it can be from API point of view, but on the ABI level in the universal case we need the vtable be part of the ABI
    * Mark: if it is fully opaque, CPython can use it in CPython ABI to pass around something useful (e.g., thread state).
    * For stable ABI: do we want one more indirection for the vtable?
        * The layout of the context can be:
            vtable_struct *vtable
            fields_struct *fields (optional: quick access to objects like Py_True, can be replaced with Get_PyTrue function)
            ...any implementation specific data after this...
        * OTOH: any implementation specific data can be before the context and we can save indirection
            * indirection can be still useful for implementation (the function table can be shared by multiple contexts)
            * indirection for function ptr calls is probably not such an issue, they should be well predicted by the CPU
            * indirection for the "fields" (if we have them in context) is probably bigger issue

Some more remarks from Ken (also in the PEP draft):

We need a shim to allow C extensions supporting the new C API to support old versions of Python that don’t support the new C API. E.g let’s say we have the new API in 3.15, an extension that wants to support 3.12-3.16 can’t possibly have to write two versions of the C extension. (Note: HPy seems to be able to do this)

Since we initially generate the PyNI functions we could generate them once into a separate library that extensions can conditionally depend on when targeting an older version. This is basically the HPy approach, where the idea was also the VMs implement HPy directly, and for other VMs that do not (i.e., CPython) there is the hpy package to use at runtime the has the shims.

Action items:
    * Everyone adds/edits stuff in the PEP draft until end of August
        * Or start a new document and share it
    * Around the first week in September Stepan/GraalPy team will merge and polish everything into publishable state
    * Mark bootstraps the API definition prototype in https://github.com/py-ni/api reusing his previous prototype
